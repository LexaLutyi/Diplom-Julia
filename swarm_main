using DifferentialEquations
using LinearAlgebra

using InteractiveUtils

include("agent_dynamic")
include("swarm_topology")


Iₙ = Matrix{Float64}(I, agents_amt, agents_amt)

Q = [A B*K; zeros(agent_order, agent_order) (A + B*K)]

Z₀ = kron(Iₙ, Q)

H = [zeros(agent_order, 2 * agent_order); -F*C F*C]

Z₁ = c * kron(L, H)
# U = Matrix(Z₁)
# Z = Z₀ + Z₁
# eigvals(Z[5:8, 5:8])

function swarm(du, u, h, p, t)
    du[:] = Z₀ * u + Z₁ * h(p, t - delay)
    """if t > 5 && add_edge!(G, 1, 3)
        L[:] = laplacian_matrix(G)
        λ[:] = real(laplacian_spectrum(G))
        μ[:] = filter(p-> ~isapprox(p, 0.0; atol=1.e-10, rtol=0), λ)
        c = 1. / min(μ...) + 0.5
        Z₁[:] = c * kron(L, H)
        Z[:] = Z₀ + Z₁
    end"""
end

"""
Задаем начальные условия
"""
h(p,t) = randn(2 * agent_order * agents_amt)
u0 = h(nothing, 0)

"""
Время интегрирования
"""
delay = 0.2
tstart = 0.
tend = 20.
tspan = (tstart, tend)

prob = DDEProblem(swarm,u0,h,tspan,delay)
sol = solve(prob)


#]add Plots # You need to install Plots.jl before your first time using it!
using Plots
plotly() # You can optionally choose a plotting backend()

#plot(sol, vars=(0,1))
#plot!(sol, vars=(0,2))

ind = Array(1:2*agent_order*agents_amt)
"""
plt = plot(sol,
            vars=filter(p->mod(p, 4) == 1, ind),
            color="green",
            dpi=1000)
plt = plot!(sol,
            vars=filter(p->mod(p, 4) == 3, ind),
            color="red",
            dpi=1000)
plt = plot!(sol,
                vars=filter(p->mod(p, 4) == 2, ind),
                color="black",
                dpi=1000)
plt = plot!(sol,
                vars=filter(p->mod(p, 4) == 0, ind),
                color="blue",
                dpi=1000)
"""
plt = plot(sol,
                vars=filter(p->p in (1, 2, 5, 6), ind),
                dpi=1000)
display(plt)
